#include <cinttypes>
#include <cstring>
#include <iostream>
#include <thread>

#include <SerialStream.h>
#include <SerialPort.h>

using namespace std::chrono_literals;

union union4byte_t
{
    uint8_t Bytes[sizeof(int32_t)];
    int32_t Int;
    float Float;
};

struct Measure
{
    int ID;
    float Value;

    // Конструкторы.
    Measure()
    {
        // ...
    }
    Measure(uint8_t *Data)
    {
        Update(Data);
    }

    // Деструктор.
    ~Measure()
    {
        // ...
    }

    // Обновление структуры через массив байт.
    void Update(uint8_t *Data)
    {
        union4byte_t Union;
        std::memcpy(Union.Bytes, Data, sizeof(int32_t));
        ID = Union.Int;
        std::memcpy(Union.Bytes, Data + sizeof(int32_t), sizeof(int32_t));
        Value = Union.Int;
    }
};

int main()
{
    // Получение имени устройства.
    std::string DevicePath;
    std::cout << "Введите имя устройства: /dev/tty";
    std::cin >> DevicePath;
    DevicePath = "/dev/tty" + DevicePath;

    // Открытие устройства.
    LibSerial::SerialStream InputStream;
    InputStream.Open(DevicePath);

    // Настройка потока.
    InputStream.SetBaudRate(LibSerial::SerialStreamBuf::BaudRateEnum::BAUD_9600); //установка скорости передачи данных
    InputStream.SetCharSize(LibSerial::SerialStreamBuf::CharSizeEnum::CHAR_SIZE_8); //устанвокаразмера символов
    InputStream.SetFlowControl(LibSerial::SerialStreamBuf::FlowControlEnum::FLOW_CONTROL_HARD); //настройка типа управления потоком
    InputStream.SetParity(LibSerial::SerialStreamBuf::ParityEnum::PARITY_ODD);
    InputStream.SetNumOfStopBits(1);
    InputStream.SetVTime(0);

    // Чтение.
    uint8_t Buffer[2 * sizeof(int32_t)];
    while(true)
    {
        InputStream.read((char*)Buffer, 2 * sizeof(int32_t));
        if(InputStream)
        {
            Measure NewMeasure(Buffer);
            std::cout << "Success!" << std::endl;
        }
        else
        {
            std::cout << InputStream.eof() << " " << InputStream.fail() << std::endl;
            std::this_thread::sleep_for(100ms);
        }
    }

    return 0;
}